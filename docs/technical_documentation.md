# Техническая документация Sirius Agent Browser

## 1. Введение

Sirius Agent Browser — это автономный агент, предназначенный для автоматизации задач в веб-браузере. Он сочетает в себе возможности больших языковых моделей (LLM) для планирования и визуальных языковых моделей (VLM) для взаимодействия с интерфейсом веб-страниц. Агент способен выполнять сложные пользовательские запросы, эмулируя действия реального человека.

## 2. Архитектура системы

Система построена по модульной архитектуре, где каждый компонент отвечает за свою область задач.

```mermaid
graph TD
    User[Пользователь (Chrome Extension)] -->|HTTP Request| Server[FastAPI Server]
    Server --> Orchestrator
    Orchestrator -->|1. Запрос плана| Planner[Planner (LLM)]
    Planner -->|JSON Plan| Orchestrator
    Orchestrator -->|2. Выполнение шагов| VLM[Vision Agent (VLM)]
    VLM -->|Скриншот/DOM| Browser[Browser Controller (Playwright)]
    Browser -->|Действия (Click, Type)| Chrome[Google Chrome]
    Chrome -->|Состояние страницы| Browser
```

---

## 3. Детальное описание классов и модулей

### 3.1. Server (`src/server.py`)

FastAPI приложение, являющееся точкой входа для внешних запросов.

**Основные функции:**

-   **Инициализация**: При старте создает глобальный экземпляр `Orchestrator`.
-   **Фоновый воркер**: Запускает отдельный поток (`threading.Thread`) для обработки очереди запросов, чтобы не блокировать основной цикл событий FastAPI.
-   **CORS**: Настроен `CORSMiddleware` для разрешения запросов с любых источников (для работы с расширением).

**Ключевые эндпоинты:**

-   `GET /health`: Возвращает `{"status": "ok"}`. Используется расширением для проверки доступности сервера (polling).
-   `POST /process`: Принимает JSON `{"request": "..."}`. Добавляет запрос в очередь воркера. Возвращает `StreamingResponse` (SSE), который транслирует статус выполнения и финальный результат клиенту.
-   `POST /stop`: Устанавливает флаг остановки в оркестраторе.

**Взаимодействие:**

-   Получает HTTP запросы от `extension/sidepanel.js`.
-   Вызывает методы `Orchestrator`.

### 3.2. Orchestrator (`src/orchestrator/orchestrator.py`)

Центральный координатор ("мозг" агента). Управляет жизненным циклом выполнения задачи.

**Атрибуты:**

-   `planner`: Экземпляр класса `Planner`.
-   `vision_agent`: Экземпляр класса `VisionAgent`.
-   `browser_controller`: Экземпляр класса `BrowserController`.
-   `memory`: Экземпляр `LongTermMemory`.
-   `_stop_requested`: Флаг для прерывания выполнения.

**Метод `process_request(user_request, ...)`:**
Это основной цикл выполнения задачи:

1.  **Инициализация сессии**: Генерирует UUID сессии.
2.  **Планирование**: Вызывает `planner.generate_plan(user_request)`.
3.  **Цикл выполнения шагов**:
    -   Итерируется по шагам плана (`plan.steps`).
    -   Проверяет флаг `_stop_requested`.
    -   Для каждого шага вызывает соответствующий метод:
        -   `navigate`/`search` -> `browser_controller`.
        -   `click`/`type`/`scroll` -> `vision_agent.execute_step`.
    -   **Верификация**: После выполнения действия может вызвать VLM для проверки успеха (сравнивает скриншот с ожидаемым результатом).
4.  **Обработка ошибок**: Ловит исключения, логирует их и возвращает сообщение об ошибке пользователю.

### 3.3. Planner (`src/planner/planner.py`)

Отвечает за преобразование естественного языка пользователя в структурированный план действий.

**Логика работы:**

-   **Промпт-инжиниринг**: Использует сложный системный промпт (`SYSTEM_PROMPT`), описывающий доступные действия (`navigate`, `click`, `type`, `search` и т.д.) и ограничения (макс. 10 шагов).
-   **LLM Integration**: Отправляет запрос в YandexGPT (через Yandex Cloud API) или OpenAI.
-   **JSON Parsing**: Ожидает от модели JSON. Использует регулярные выражения для извлечения JSON-блока из ответа модели (так как модели могут добавлять пояснительный текст).
-   **Валидация**: Использует Pydantic модели (`src/planner/models.py`) для строгой проверки структуры плана. Если валидация не проходит, выбрасывает `PlannerError`.

**Модели данных (`src/planner/models.py`):**

-   `Step`: Описывает одно действие. Поля: `step_id`, `action`, `description`, `expected_result`.
-   `Plan`: Содержит список `Step`, поле `reasoning` (цепочка рассуждений модели) и `needs_vision` (флаг необходимости скриншота для планирования).

### 3.4. Vision Agent (`src/vlm/vlm.py` и `src/vlm/agent.py`)

Этот модуль разделен на два уровня абстракции: высокоуровневое управление (`VisionAgent`) и низкоуровневое взаимодействие с API (`VLMAgent`).

**Class `VisionAgent` (`vlm.py`):**

-   **Роль**: Исполнитель действий, требующих взаимодействия с интерфейсом.
-   **Human-like Mouse Movement**: Метод `_human_like_mouse_move` реализует алгоритм перемещения курсора по кривым Безье с добавлением случайного шума и переменной скоростью. Это критично для обхода анти-бот систем.
-   **Выполнение шагов**: Метод `execute_step` принимает объект `Step` и страницу Playwright.
    -   Для `click`/`type`: Сначала пытается найти элемент по селектору. Если не находит — делает скриншот и отправляет в VLM для получения координат.
    -   Для `scroll`: Эмулирует прокрутку колесиком мыши.

**Class `VLMAgent` (`agent.py`):**

-   **Роль**: Клиент для Vision Language Model (Gemma-3 / GPT-4o).
-   **API Calls**: Отправляет изображения (в base64) и текстовые промпты в API.
-   **Верификация**: Использует специальный промпт (`VERIFY_SYSTEM_PROMPT`) для проверки, соответствует ли текущее состояние страницы (скриншот) ожидаемому результату шага. Возвращает `TRUE`/`FALSE` и объяснение.

### 3.5. Browser Controller (`src/browser/browser_controller.py`)

Обертка над библиотекой Microsoft Playwright.

**Основные функции:**

-   **CDP Connection**: Подключается к существующему экземпляру Chrome через Chrome DevTools Protocol (порт 9222). Это позволяет управлять браузером, запущенным пользователем, сохраняя куки и сессии.
-   **Управление контекстом**:
    -   `start()`: Инициализирует подключение.
    -   `get_current_page()`: Возвращает активную вкладку.
    -   `navigate(url)`: Переходит по URL.
-   **Extension Check**: Метод `is_extension_installed(name)` использует низкоуровневые команды CDP (`Target.getTargets`) для проверки, загружено ли расширение агента.

### 3.6. Long Term Memory (`src/memory/long_term_memory.py`)

Система долговременной памяти для запоминания успешных действий.

**Реализация:**

-   **Хранилище**: JSON-файл (`memory_db.json`).
-   **Структура данных**: Список записей, содержащих `domain`, `task` (описание задачи), `steps` (успешный план) и `timestamp`.
-   **Поиск (`retrieve_relevant`)**:
    1.  Фильтрует записи по домену текущего URL.
    2.  Использует `difflib.SequenceMatcher` для нечеткого сравнения текущей задачи с сохраненными задачами.
    3.  Возвращает наиболее релевантный опыт, который затем подставляется в контекст планировщика.

### 3.7. Tools (`src/tools/`)

Набор вспомогательных инструментов.

-   **Search (`search.py`)**: Реализует поиск через Yandex Search API v2.
    -   Формирует XML/JSON запрос.
    -   Парсит ответ, извлекая заголовки, сниппеты и URL.
    -   _Примечание_: В текущей версии агент чаще использует прямой поиск через интерфейс браузера (ya.ru), имитируя пользователя, но этот модуль доступен как fallback или для API-режима.

---

## 4. Поток данных (Data Flow) детально

1.  **User Request**: Пользователь вводит "Найди билеты в Москву" в Side Panel.
2.  **Server**: `POST /process` получает запрос, создает задачу в очереди.
3.  **Orchestrator**:
    -   Берет задачу.
    -   Обращается к `Memory`: "Есть ли опыт покупки билетов?".
    -   Обращается к `Planner`: "Составь план для 'Найди билеты в Москву' с учетом опыта [...]".
4.  **Planner**:
    -   LLM возвращает JSON:
        ```json
        {
          "reasoning": "Нужно найти агрегатор...",
          "steps": [
            {"action": "search", "description": "Search for 'aviasales'", ...},
            {"action": "click", "description": "Click first result", ...}
          ]
        }
        ```
5.  **Orchestrator (Execution Loop)**:
    -   **Step 1 (Search)**: Вызывает `browser_controller.page.goto("https://ya.ru")` -> `type("aviasales")` -> `press("Enter")`.
    -   **Step 2 (Click)**:
        -   `VisionAgent` делает скриншот.
        -   Отправляет в VLM: "Где ссылка на Aviasales?".
        -   VLM возвращает координаты `[x, y]`.
        -   `VisionAgent` двигает мышь по кривой Безье в `[x, y]` и кликает.
    -   **Verification**: Делает новый скриншот. VLM проверяет: "Мы на сайте Aviasales?". Если да -> следующий шаг.
6.  **Completion**: Результат отправляется на фронтенд через SSE.

---

## 5. Конфигурация и переменные окружения

Файл `.env` управляет поведением всех классов:

| Переменная             | Класс-потребитель               | Описание                                  |
| :--------------------- | :------------------------------ | :---------------------------------------- |
| `YANDEX_CLOUD_API_KEY` | `Planner`, `VLMAgent`, `Search` | Авторизация в сервисах Яндекса.           |
| `YANDEX_CLOUD_FOLDER`  | `Planner`, `VLMAgent`           | ID каталога ресурсов.                     |
| `CHROME_DEBUG_PORT`    | `BrowserController`             | Порт для подключения к CDP (9222).        |
| `HEADLESS`             | `BrowserController`             | Режим запуска браузера (скрытый/видимый). |
