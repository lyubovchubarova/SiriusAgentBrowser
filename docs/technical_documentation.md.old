# Техническая документация Sirius Agent Browser

## 1. Введение

Sirius Agent Browser — это автономный агент, предназначенный для автоматизации задач в веб-браузере. Он сочетает в себе возможности больших языковых моделей (LLM) для планирования и визуальных языковых моделей (VLM) для взаимодействия с интерфейсом веб-страниц. Агент способен выполнять сложные пользовательские запросы, эмулируя действия реального человека.

## 2. Архитектура системы

Система построена по модульной архитектуре, где каждый компонент отвечает за свою область задач.

```mermaid
graph TD
    User[Пользователь (Chrome Extension)] -->|HTTP Request| Server[FastAPI Server]
    Server --> Orchestrator
    Orchestrator -->|1. Запрос плана| Planner[Planner (LLM)]
    Planner -->|JSON Plan| Orchestrator
    Orchestrator -->|2. Выполнение шагов| VLM[Vision Agent (VLM)]
    VLM -->|Скриншот/DOM| Browser[Browser Controller (Playwright)]
    Browser -->|Действия (Click, Type)| Chrome[Google Chrome]
    Chrome -->|Состояние страницы| Browser
```

### Основные компоненты:

1.  **Extension (Расширение)**: Пользовательский интерфейс в боковой панели браузера.
2.  **Server (Сервер)**: API-шлюз, принимающий команды от расширения.
3.  **Orchestrator (Оркестратор)**: "Мозг" системы, координирующий работу всех модулей.
4.  **Planner (Планировщик)**: Отвечает за декомпозицию задачи на шаги.
5.  **VLM Agent (Визуальный агент)**: Отвечает за выполнение конкретных действий на странице, используя визуальный анализ.
6.  **Browser Controller**: Обертка над Playwright для управления браузером.

---

## 3. Описание компонентов

### 3.1. Server (`src/server.py`)

FastAPI приложение, которое слушает порт 8000.

-   **Endpoints**:
    -   `/health`: Проверка статуса сервера.
    -   `/process`: Основной эндпоинт для обработки запросов пользователя.
    -   `/stop`: Остановка текущего выполнения.
-   **Роль**: Обеспечивает связь между Chrome-расширением и Python-ядром агента.

### 3.2. Orchestrator (`src/orchestrator/orchestrator.py`)

Центральный класс `Orchestrator`.

-   **Задачи**:
    -   Инициализация компонентов (`Planner`, `VisionAgent`, `BrowserController`).
    -   Управление жизненным циклом сессии (Session ID).
    -   Обработка запроса: получение плана -> цикл выполнения шагов.
    -   Логирование действий.
-   **Ключевой метод**: `process_request(user_request, ...)` — запускает весь пайплайн обработки задачи.

### 3.3. Planner (`src/planner/`)

Использует LLM (YandexGPT/Gemma или OpenAI) для создания плана действий.

-   **Модели данных (`models.py`)**:
    -   `Plan`: Содержит список шагов, рассуждение (reasoning) и оценку времени.
    -   `Step`: Описание конкретного действия (`navigate`, `click`, `type`, `search` и т.д.).
-   **Логика (`planner.py`)**:
    -   Генерирует промпт для LLM с описанием доступных действий.
    -   Парсит JSON-ответ от модели.
    -   Валидирует план на соответствие ограничениям (макс. 10 шагов, корректные ID шагов).

### 3.4. Vision Agent (`src/vlm/`)

Компонент, отвечающий за выполнение действий ("Руки" и "Глаза").

-   **Класс `VisionAgent` (`vlm.py`)**:
    -   Управляет высокоуровневыми действиями.
    -   Реализует `_human_like_mouse_move` для эмуляции движения мыши по кривым Безье (защита от анти-бот систем).
-   **Класс `VLMAgent` (`agent.py`)**:
    -   Взаимодействует с VLM API (Yandex Cloud / OpenAI).
    -   Анализирует скриншоты для проверки успешности выполнения действий (верификация).

### 3.5. Browser Controller (`src/browser/`)

Обертка над библиотекой Playwright.

-   **Класс `BrowserController`**:
    -   Управляет подключением к браузеру через CDP (Chrome DevTools Protocol).
    -   Предоставляет методы для работы со страницами, вкладками и элементами.
    -   `is_extension_installed`: Проверяет наличие расширения через CDP.

---

## 4. Поток данных (Data Flow)

1.  **Инициализация**: Пользователь открывает боковую панель. Расширение пингует `/health`.
2.  **Запрос**: Пользователь вводит "Найди билеты в Москву".
3.  **Планирование**:
    -   `Orchestrator` передает запрос в `Planner`.
    -   `Planner` формирует промпт и отправляет в LLM.
    -   LLM возвращает JSON-план: `[Search "билеты Москва", Click "Aviasales", ...]`.
4.  **Выполнение**:
    -   `Orchestrator` берет первый шаг.
    -   Если шаг `navigate` или `search` — вызывает методы `BrowserController`.
    -   Если шаг требует взаимодействия (`click`, `type`) — `VisionAgent` анализирует DOM/скриншот, находит координаты элемента и выполняет действие.
5.  **Обратная связь**: После каждого шага агент может делать скриншот для верификации успеха (через VLM).
6.  **Завершение**: Результат возвращается пользователю в чат.

---

## 5. Конфигурация

Настройка производится через файл `.env`.

| Переменная             | Описание                                                   |
| :--------------------- | :--------------------------------------------------------- |
| `YANDEX_CLOUD_API_KEY` | API ключ для Yandex Cloud (LLM/VLM).                       |
| `YANDEX_CLOUD_FOLDER`  | ID каталога в Yandex Cloud.                                |
| `OPENAI_API_KEY`       | (Опционально) Ключ OpenAI, если используется как fallback. |
| `CHROME_DEBUG_PORT`    | Порт для отладки Chrome (по умолчанию 9222).               |
| `HEADLESS`             | Запуск браузера в фоновом режиме (`true`/`false`).         |

---

## 6. Расширение Chrome (`extension/`)

-   **Manifest V3**: Использует современные стандарты расширений.
-   **Side Panel**: Основной интерфейс (`sidepanel.html`, `sidepanel.js`).
-   **Communication**: Использует `fetch` для общения с локальным сервером (`127.0.0.1:8000`).
-   **Server-Sent Events (SSE)**: (В планах/частично реализовано) для стриминга ответов от агента в реальном времени.

## 7. Особенности реализации

-   **Human-like Interaction**: Агент не просто "телепортирует" клики, а двигает мышь с шумом и ускорением/замедлением, чтобы имитировать поведение человека.
-   **Hybrid Intelligence**: Использует текстовую модель для планирования (быстро и дешево) и визуальную модель только там, где это необходимо (анализ интерфейса, верификация).
-   **CDP Connection**: Агент подключается к уже запущенному браузеру пользователя, а не создает новый инстанс каждый раз, что позволяет сохранять куки и сессии.
